ЛАБОРАТОРНАЯ РАБОТА №1: Амортизированный анализ роста динамического массива

### Цель работы
Научиться объяснять (и считать), почему добавление в конец динамического массива при удвоении ёмкости имеет амортизированную сложность O(1).

### Теоретическая справка (кратко)
Реаллокация стоит O(k), где `k` — число элементов, которые переносим. Если ёмкость растёт геометрически, количество переносов суммарно линейно.

### Пошаговые инструкции
1. Предположи стратегию роста: `capacity *= 2`.
2. Для `n` вставок выпиши моменты реаллокации: при заполнении 1,2,4,8,…
3. Посчитай суммарное число перемещённых элементов.
4. Раздели на `n` и сделай вывод об амортизированной сложности.

### Необходимые формулы и данные
- Геометрическая прогрессия: `1 + 2 + 4 + ... + 2^k = 2^(k+1) - 1`.

### Контрольные вопросы
1. Почему в худшем случае добавление может быть O(n)?
Так как худшим случаем будет момент реалокации
2. Что означает “амортизированно O(1)”?
Это значит что средняя сложность при добавлении n элементов в массив будет O(1)
3. Почему рост на +1 (capacity = capacity + 1) приводит к плохой сложности?
Придобавлении нового элемента каждый раз будет происходить реалокация




ЛАБОРАТОРНАЯ РАБОТА №2: Эксперимент с “реаллокацией” в Java (на своём динамическом массиве)

### Цель работы
Понять на практике, что происходит при расширении внутреннего массива (реаллокации) и почему “держать ссылку на старый буфер” — плохая идея.

### Теоретическая справка (кратко)
При расширении динамический массив выделяет новый `int[]` и копирует туда элементы. Старый `int[]` остаётся как отдельный объект, но контейнер им больше не пользуется.

### Пошаговые инструкции
1. Реализуй класс `DynamicIntArray`, который хранит `int[] buffer`, `int size`.
2. Возьми ссылку на внутренний буфер (через debug-метод).
3. Делай `add(x)`, пока буфер не расширится.
4. Проверь, что ссылка на старый `int[]` и новый `int[]` — разные объекты (в Java можно сравнить `==`).
5. Сделай вывод: почему нельзя “рассчитывать” на старый буфер.
Расчитывать на старый буфер не стоит так как может быть не актуален.

### Необходимые формулы и данные
Формул нет — важна логика: “сменился буфер ⇒ старые адреса невалидны”.

### Контрольные вопросы
1. Всегда ли `push_back` инвалидирует итераторы?
Без реаллокации: элементы остаются на тех же местах в памяти
С реаллокацией: весь массив копируется в новое место, старые указатели/итераторы становятся невалидными
2. Можно ли гарантировать отсутствие реаллокации?
3. Можно если знать для чего нужна структура или сразу выделить с запасом
3. Почему `reserve` помогает?
Заранее выделенная память помогает избежать лишних реалокаций, предсказуемая сложность, не теряется ссылка на массив.



## Задача 1 (лёгкая): Адрес элемента массива
**Условие:** массив `int a[100]` начинается по адресу `ptr = 1000` (в байтах), `sizeof(int)=4`. Найти адрес `a[37]`.
1000 + 37 × 4 = 1000 + 148 = 1148
## Задача 2 (лёгкая): Что быстрее — массив или список — для `a[i]`?
**Условие:** почему `a[i]` для массива O(1), а для связного списка — O(n)?
Мы не можем использовать арифметику указателей для нахождения элемента в массиве. В связном списке приходится проходить по каждой ссылке от начала и до нужному элемента
## Задача 3 (средняя): Сколько реаллокаций будет у вектора?
**Условие:** dynamic array стартует с `capacity=1` и удваивается. Сколько расширений произойдёт при добавлении `n=1000` элементов?
Будет 10 расширений на добавлении 513 элемента массив расширится до 1024 что будет хватать для 1000
## Задача 4 (средняя): Вставка в середину вектора
**Условие:** почему вставка в середину динамического массива стоит O(n), даже если расширения массива нет?
Вставка O(n) в середину дин массива предпологает сдвиг элементов перед ячейкой вправа и тут не важно расширяется массив или нет
## Задача 5 (сложная): Амортизированная оценка при росте на +k
**Условие:** пусть `capacity` увеличивается не в 2 раза, а на фиксированное число `k` (например, +100). Оцени сложность серии из `n` добавлений.
????????
## Задача 6 (сложная): Как сделать, чтобы указатели на элементы не ломались?
**Условие:** предложи 2 способа “не терять” ссылки на элементы при росте коллекции.
Создать массив нужного размера чтобы не пришлось ралоцировать
Хранить индексы на элементы